package main

{{$pascalDBModel := topascal .DBModel}}
{{$lowerDBModel := tolower .DBModel}}

import (
	"net"
	"net/http"

	"github.com/caring/{{.Name}}/api/pb"
	"github.com/caring/{{.Name}}/internal/domain/{{$lowerDBModel}}"
	"github.com/caring/{{.Name}}/internal/handlers"
	"github.com/caring/{{.Name}}/internal/service"
	"github.com/caring/go-packages/v2/pkg/logging"
	"github.com/soheilhy/cmux"
)

func main() {
	l := initLogger()
	defer l.Sync()
	defer l.Close()
	
	t := initTracing(l)
	defer t.Close()
	
	{{if .UseDB}}dbConnection := setDBConnectionString(l)
	migrateDatabase(l, dbConnection)
	database := initDB(l, dbConnection){{end}}

	// main listener
	lis, err := net.Listen("tcp", ":"+envMust("PORT"))
	if err != nil {
		l.Fatal("Failed to initialize net listener:" + err.Error())
	}

	// create a cmux
	m := cmux.New(lis)
	// match connections in order:
	// first grpc, then http.
	grpcL := m.Match(cmux.HTTP2())
	httpL := m.Match(cmux.HTTP1Fast())

	svc := &service.Service{
		Logger: l,
		{{$pascalDBModel}}: &handlers.{{$pascalDBModel}}{
			{{if .UseDB}}Store: {{$lowerDBModel}}.Service{
				DB: database,
				Logger: l,{{end}}
			},
		},
	}

	// register the server with gRPC
	g := createGRPCServer(l, t)
	pb.Register{{topascal .Name}}ServiceServer(g, svc)

	// Add a health check endpoint for automated container monitoring
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	// make an error channel to collect the exits of each protocol's Serve()
	eChan := make(chan error)

	// start listeners for each protocol
	go func() { eChan <- g.Serve(grpcL) }()
	go func() { eChan <- http.Serve(httpL, nil) }()

	// all systems are a go
	l.Info("server started: multiplexed http/1, http/2",
		logging.String("port", envMust("PORT")),
		logging.String("multiplexed", "true"),
	)

	// serve it up
	go func() { eChan <- m.Serve() }()

	for err := range eChan {
		if err != nil {
			l.Error("Error from one of the HTTP protocols:" + err.Error())
		}
	}
}

