package main

// This file contains helpers that initialize app insight, developer tooling and database set up that might be run on any given app
import (
	{{if .UseDB}}"fmt"
	"database/sql"{{end}}

	"log"
	"errors"
	"os"

	{{if .UseDB}}"github.com/caring/{{tolower .Name}}/internal/db"
	_ "github.com/go-sql-driver/mysql"
	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/mysql"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	_ "github.com/golang-migrate/migrate/v4/source/github"{{end}}

	"github.com/caring/go-packages/v2/pkg/grpc_middleware"
	"github.com/caring/go-packages/v2/pkg/logging"
	"github.com/caring/go-packages/v2/pkg/tracing"

	"google.golang.org/grpc"
)

// establish logging from env config
func initLogger() *logging.Logger {
	log.Print("Initializing logger")
	l, err := logging.NewLogger(&logging.Config{})
	if err != nil {
		log.Fatal("Error initializing logger:", err.Error())
	}
	log.Print("Done")
	return l
}

// configure tracing form env
func initTracing(logger *logging.Logger) *tracing.Tracer {
	logger.Debug("Initializing Tracing")
	tracer, err := tracing.NewTracer(&tracing.Config{
		Logger: logger,
	})
	if err != nil {
		logger.Fatal("Failed to establish tracing:" + err.Error())
	}
	logger.Debug("Done")
	return tracer
}

// create protocol server with chained interceptors
func createGRPCServer(logger *logging.Logger, tracer *tracing.Tracer) *grpc.Server {
	return grpc.NewServer(
		grpc_middleware.NewGRPCChainedUnaryInterceptor(grpc_middleware.UnaryOptions{
			Logger: logger,
			Tracer: tracer,
		}),
		grpc_middleware.NewGRPCChainedStreamInterceptor(grpc_middleware.StreamOptions{
			Logger: logger,
			Tracer: tracer,
		}),
	)
}

{{if .UseDB}}
// create the db connection string from env
func setDBConnectionString(logger *logging.Logger) string {
	logger.Debug("Creating DB connection string")
	user := envMust("DB_USER")
	pwd := envMust("DB_PWD")
	host := envMust("DB_HOST")
	port := envMust("DB_PORT")
	schema := envMust("DB_SCHEMA")
	logger.Debug("Done")
	return user + ":" + pwd + "@tcp(" + host + ":" + port + ")/" + schema
}

// perform the database migration from env config
func migrateDatabase(logger *logging.Logger, connectionString string) {
	logger.Info("Connecting to DB")

	m, err := migrate.New(
		envMust("DB_MIGRATIONS_SRC"),
		"mysql://"+connectionString,
	)
	if err != nil {
		logger.Fatal("Failure running migrations to update database:" + err.Error())
	}
	logger.Info("Running migration")
	err = m.Up()
	if err != nil {
		if err != migrate.ErrNoChange {
			logger.Fatal("Migrations Failed: " + err.Error())
		}
	}
	version, dirty, mErr := m.Version()
	logger.Info(fmt.Sprint("Current migration version: ", version))
	logger.Info(fmt.Sprint("Migration dirty: ", dirty))
	if mErr != nil {
		logger.Fatal("Migration error: " + mErr.Error())
	}
	logger.Debug("Done")
}

// initialize the DB service
func initDB(logger *logging.Logger, connectionString string) *sql.DB {
	logger.Debug("Initializing DB")
	// establish a store and connection to the db
	db, err := db.Open(connectionString)
	if err != nil {
		logger.Fatal("Failed to initialize DB:" + err.Error())
	}
	logger.Debug("DB connection initialized")
	return db
} {{end}}

// fetches and returns the given env variable, fatals and
// captures an exception if the variable is an empty string
func envMust(varName string) string {
	value := os.Getenv(varName)
	if value == "" {
		e := errors.New("environment variable missing - " + varName)
		log.Fatalln(e.Error())
	}
	return value
}
