package {{tolower .DBModel}}

import (
  "context"
  "database/sql"
  "database/sql/driver"
  "testing"

  "github.com/DATA-DOG/go-sqlmock"
  "github.com/caring/go-packages/pkg/uuid"
  "github.com/stretchr/testify/assert"

  "github.com/caring/{{.Name}}/api/pb"
)

{{$pascalDbModel := topascal .DBModel}}

func NewTestDB() (Store, sqlmock.Sqlmock, error) {
  db, mock, err := sqlmock.New()
  if err != nil {
    return nil, nil, err
  }

  s := Service{
    DB:    db,
  }

  return &s, mock, nil
}

// ensures that casting from proto to store structs occurs correctly
func TestNew{{$pascalDbModel}}(t *testing.T) {
  {{.DBModel}}ID := uuid.MustParse("72bc87f3-4a9f-4d05-93fe-844d3cd94c65")
  proto := pb.Create{{$pascalDbModel}}Request{
    Name:       "Foobar",
  }

  res, err := New{{$pascalDbModel}}({{.DBModel}}ID.String(), &proto)

  assert.NoError(t, err, "Expected NewCategory not to error")
  assert.Equal(t, {{.DBModel}}ID, res.ID, "Expected UUIDs to match")
  assert.Equal(t, proto.Name, res.Name, "Expected name to be correctly assigned")
}

// ensures that casting from store to proto response occurs correctly
func Test{{$pascalDbModel}}_Proto(t *testing.T) {
  {{.DBModel}}ID := uuid.MustParse("72bc87f3-4a9f-4d05-93fe-844d3cd94c65")

  {{.DBModel}} := &{{$pascalDbModel}}{
    ID:  {{.DBModel}}ID,
    Name:       "foobar",
  }

  res := {{.DBModel}}.Proto()

  assert.Equal(t, {{.DBModel}}ID.String(), res.{{$pascalDbModel}}Id, "Expected field to be mapped back to proto object correctly")
  assert.Equal(t, "foobar", res.Name, "Expected field to be mapped back to proto object correctly")
}

func Test{{.DBModel}}Service_get(t *testing.T) {
	{{.DBModel}}TestID := uuid.MustParse("72bc87f3-4a9f-4d05-93fe-844d3cd94c65")

	args := []driver.Value{
		"72bc87f3-4a9f-4d05-93fe-844d3cd94c65",
	}

	t.Run("get request", func(t *testing.T) {
		store, mock, err := NewTestDB()
		if ok := assert.NoError(t, err, "Expected no error"); !ok {
			assert.FailNow(t, "test setup failed")
		}

		mock.ExpectBegin()
		mock.ExpectQuery("SELECT {{.DBModel}}s").
			WillReturnRows(
				sqlmock.NewRows([]string{"{{.DBModel}}_id", "name"}).
					AddRow({{.DBModel}}TestID, "Foobar"),
			)

		res, err := store.Get(context.Background(), nil, {{.DBModel}}TestID)
		assert.NoError(t, err, "Expecting no query error")

		assert.Equal(t, {{.DBModel}}TestID, res.ID, "Expected correct {{.DBModel}}Test ID to be returned")
		assert.Equal(t, "Foobar", res.Name, "Expected correct name to be returned")

		err = mock.ExpectationsWereMet()
		assert.NoError(t, err, "Expecting all mock conditions to be met")
	})

	// ensures a record not found is handled correctly
	t.Run("No rows returned", func(t *testing.T) {
		store, mock, err := NewTestDB()
		if ok := assert.NoError(t, err, "Expected no error"); !ok {
			assert.FailNow(t, "test setup failed")
		}

		mock.ExpectQuery("SELECT {{.DBModel}}s").
			WithArgs(args...).WillReturnError(sql.ErrNoRows)

		_, err = store.Get(context.Background(), nil, {{.DBModel}}TestID)
		assert.EqualError(t, err, "Error executing get {{.DBModel}} - 72bc87f3-4a9f-4d05-93fe-844d3cd94c65: the record you are attempting to find or update is not found", "Expecting no query error")

		err = mock.ExpectationsWereMet()
		assert.NoError(t, err, "Expecting all mock conditions to be met")
	})
}

func Test{{$pascalDbModel}}Service_create(t *testing.T) {
  {{.DBModel}}ID := uuid.MustParse("72bc87f3-4a9f-4d05-93fe-844d3cd94c65")
  
  input := &{{$pascalDbModel}}{
    ID:   {{.DBModel}}ID,
    Name: "Foobar",
  }
  args := []driver.Value{
    "72bc87f3-4a9f-4d05-93fe-844d3cd94c65",
    "Foobar",
  }

  t.Run("With a provided transaction", func(t *testing.T) {
    store, mock, err := NewTestDB()
    if ok := assert.NoError(t, err, "Expected no error"); !ok {
      assert.FailNow(t, "test setup failed")
    }

    mock.ExpectBegin()
    mock.ExpectExec("INSERT {{.DBModel}}s").
      WithArgs(args...).
      WillReturnResult(sqlmock.NewResult(0, 1))

    err = store.Create(context.Background(), nil, input)
    assert.NoError(t, err, "Expecting no query error")

    err = mock.ExpectationsWereMet()
    assert.NoError(t, err, "Expecting all mock conditions to be met")
  })

  // ensures that a failed record create is handled correctly
  t.Run("Failed record create", func(t *testing.T) {
    store, mock, err := NewTestDB()
    if ok := assert.NoError(t, err, "Expected no error"); !ok {
      assert.FailNow(t, "test setup failed")
    }

    mock.ExpectExec("INSERT {{.DBModel}}s").
      WithArgs(args...).
      WillReturnResult(sqlmock.NewResult(0, 0))

    err = store.Create(context.Background(), nil, input)
    assert.EqualError(t, err, "Error executing create {{.DBModel}} - &{72bc87f3-4a9f-4d05-93fe-844d3cd94c65 Foobar}: no new rows were created", "Expecting no query error")

    err = mock.ExpectationsWereMet()
    assert.NoError(t, err, "Expecting all mock conditions to be met")
  })
}

func Test{{$pascalDbModel}}Service_update(t *testing.T) {
  {{.DBModel}}ID := uuid.MustParse("72bc87f3-4a9f-4d05-93fe-844d3cd94c65")
  
  input := &{{$pascalDbModel}}{
    ID:   {{.DBModel}}ID,
    Name: "Foobar",
  }
  args := []driver.Value{
    "Foobar",
    "72bc87f3-4a9f-4d05-93fe-844d3cd94c65",
  }

  t.Run("With a provided transaction", func(t *testing.T) {
    store, mock, err := NewTestDB()
    if ok := assert.NoError(t, err, "Expected no error"); !ok {
      assert.FailNow(t, "test setup failed")
    }

    mock.ExpectBegin()
    mock.ExpectExec("UPDATE {{.DBModel}}s").
      WithArgs(args...).
      WillReturnResult(sqlmock.NewResult(0, 1))

    err = store.Update(context.Background(), nil, input)
    assert.NoError(t, err, "Expecting no query error")

    err = mock.ExpectationsWereMet()
    assert.NoError(t, err, "Expecting all mock conditions to be met")
  })

  // ensures correct error to be returned when no rows are updated
  t.Run("No updates occurred", func(t *testing.T) {
    store, mock, err := NewTestDB()
    if ok := assert.NoError(t, err, "Expected no error"); !ok {
      assert.FailNow(t, "test setup failed")
    }

    mock.ExpectExec("UPDATE {{.DBModel}}s").
      WithArgs(args...).
      WillReturnResult(sqlmock.NewResult(0, 0))

    err = store.Update(context.Background(), nil, input)
    assert.EqualError(t, err, "Error executing update {{.DBModel}} - &{72bc87f3-4a9f-4d05-93fe-844d3cd94c65 Foobar}: no rows affected", "Expecting no query error")

    err = mock.ExpectationsWereMet()
    assert.NoError(t, err, "Expecting all mock conditions to be met")
  })
}

func Test{{$pascalDbModel}}Service_delete(t *testing.T) {
  {{.DBModel}}ID := uuid.MustParse("72bc87f3-4a9f-4d05-93fe-844d3cd94c65")
 
  args := []driver.Value{
    "72bc87f3-4a9f-4d05-93fe-844d3cd94c65",
  }

  // ensures that execution outside of a transaction occurs without error
  t.Run("Without a provided transaction", func(t *testing.T) {
    store, mock, err := NewTestDB()
    if ok := assert.NoError(t, err, "Expected no error"); !ok {
      assert.FailNow(t, "test setup failed")
    }

    mock.ExpectExec("UPDATE {{.DBModel}}s").
      WithArgs(args...).
      WillReturnResult(sqlmock.NewResult(0, 1))

    err = store.Delete(context.Background(), nil, {{.DBModel}}ID)
    assert.NoError(t, err, "Expecting no query error")

    err = mock.ExpectationsWereMet()
    assert.NoError(t, err, "Expecting all mock conditions to be met")
  })

  // ensures that deleting a non existent record is handled correctly
  t.Run("Deleting a non existent record", func(t *testing.T) {
    store, mock, err := NewTestDB()
    if ok := assert.NoError(t, err, "Expected no error"); !ok {
      assert.FailNow(t, "test setup failed")
    }

    mock.ExpectExec("UPDATE {{.DBModel}}s").
      WithArgs(args...).
      WillReturnResult(sqlmock.NewResult(0, 0))

    err = store.Delete(context.Background(), nil, {{.DBModel}}ID)
    assert.EqualError(t, err, "Error executing delete {{.DBModel}} - 72bc87f3-4a9f-4d05-93fe-844d3cd94c65: the record you are attempting to find or update is not found", "Expecting not found error")

    err = mock.ExpectationsWereMet()
    assert.NoError(t, err, "Expecting all mock conditions to be met")
  })
}
