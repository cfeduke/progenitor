package db

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/caring/go-packages/pkg/errors"
	"github.com/google/uuid"

	"github.com/caring/{{.Name}}/pb"
)

{{$pascalDbModel := topascal .dbModel}}

// {{.dbModel}}Service provides an API for interacting with the {{.dbModel}}s table
type {{.dbModel}}Service struct {
	db    *sql.DB
	stmts map[string]*sql.Stmt
}

// {{$pascalDbModel}} is a struct representation of a row in the {{.dbModel}}s table
type {{$pascalDbModel}} struct {
	ID  	uuid.UUID
	Name  string
}

// proto{{$pascalDbModel}} is an interface that most proto {{.dbModel}} objects will satisfy
type proto{{$pascalDbModel}} interface {
	GetName() string
}

// New{{$pascalDbModel}} is a convenience helper cast a proto {{.dbModel}} to it's DB layer struct
func New{{$pascalDbModel}}(ID string, proto proto{{$pascalDbModel}}) (*{{$pascalDbModel}}, error) {
	mID, err := ParseUUID(ID)
	if err != nil {
		return nil, err
	}

	return &{{$pascalDbModel}}{
		ID:  	mID,
		Name: proto.GetName(),
	}, nil
}

// ToProto casts a db {{.dbModel}} into a proto response object
func (m *{{$pascalDbModel}}) ToProto() *pb.{{$pascalDbModel}}Response {
	return &pb.{{$pascalDbModel}}Response{
		Id:  				m.ID.String(),
		Name:       m.Name,
	}
}

// Get fetches a single {{.dbModel}} from the db
func (svc *{{.dbModel}}Service) Get(ctx context.Context, ID uuid.UUID) (*{{$pascalDbModel}}, error) {
	return svc.get(ctx, false, ID)
}

// GetTx fetches a single {{.dbModel}} from the db inside of a tx from ctx
func (svc *{{.dbModel}}Service) GetTx(ctx context.Context, ID uuid.UUID) (*{{$pascalDbModel}}, error) {
	return svc.get(ctx, true, ID)
}

// get fetches a single {{.dbModel}} from the db
func (svc *{{.dbModel}}Service) get(ctx context.Context, useTx bool, ID uuid.UUID) (*{{$pascalDbModel}}, error) {
	errMsg := func() string { return "Error executing get {{.dbModel}} - " + fmt.Sprint(ID) }

	var (
		stmt *sql.Stmt
		err  error
		tx   *sql.Tx
	)

	if useTx {

		if tx, err = FromCtx(ctx); err != nil {
			return nil, err
		}

		stmt = tx.Stmt(svc.stmts["get-{{.dbModel}}"])
	} else {
		stmt = svc.stmts["get-{{.dbModel}}"]
	}

	p := {{$pascalDbModel}}{}

	err = stmt.QueryRowContext(ctx, ID).
		Scan(&m.{{$pascalDbModel}}ID, &m.Name)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return nil, errors.Wrap(ErrNotFound, errMsg())
		}

		return nil, errors.Wrap(err, errMsg())
	}

	return &p, nil
}

// Create a new {{.dbModel}}
func (svc *{{.dbModel}}Service) Create(ctx context.Context, input *{{$pascalDbModel}}) error {
	return svc.create(ctx, false, input)
}

// CreateTx creates a new {{.dbModel}} withing a tx from ctx
func (svc *{{.dbModel}}Service) CreateTx(ctx context.Context, input *{{$pascalDbModel}}) error {
	return svc.create(ctx, true, input)
}

// create a new {{.dbModel}}. if useTx = true then it will attempt to create the {{.dbModel}} within a transaction
// from context.
func (svc *{{.dbModel}}Service) create(ctx context.Context, useTx bool, input *{{$pascalDbModel}}) error {
	errMsg := func() string { return "Error executing create {{.dbModel}} - " + fmt.Sprint(input) }

	var (
		stmt *sql.Stmt
		err  error
		tx   *sql.Tx
	)

	if useTx {

		if tx, err = FromCtx(ctx); err != nil {
			return err
		}

		stmt = tx.Stmt(svc.stmts["create-{{.dbModel}}"])
	} else {
		stmt = svc.stmts["create-{{.dbModel}}"]
	}

	result, err := stmt.ExecContext(ctx, input.{{$pascalDbModel}}ID, input.Name)
	if err != nil {
		return errors.Wrap(err, errMsg())
	}

	rowCount, err := result.RowsAffected()
	if err != nil {
		return errors.Wrap(err, errMsg())
	}

	if rowCount == 0 {
		return errors.Wrap(ErrNotCreated, errMsg())
	}

	return nil
}

// Update updates a single {{.dbModel}} row in the DB
func (svc *{{.dbModel}}Service) Update(ctx context.Context, input *{{$pascalDbModel}}) error {
	return svc.update(ctx, false, input)
}

// UpdateTx updates a single {{.dbModel}} row in the DB within a tx from ctx
func (svc *{{.dbModel}}Service) UpdateTx(ctx context.Context, input *{{$pascalDbModel}}) error {
	return svc.update(ctx, true, input)
}

// update a {{.dbModel}}. if useTx = true then it will attempt to update the {{.dbModel}} within a transaction
// from context.
func (svc *{{.dbModel}}Service) update(ctx context.Context, useTx bool, input *{{$pascalDbModel}}) error {
	errMsg := func() string { return "Error executing update {{.dbModel}} - " + fmt.Sprint(input) }

	var (
		stmt *sql.Stmt
		err  error
		tx   *sql.Tx
	)

	if useTx {

		if tx, err = FromCtx(ctx); err != nil {
			return err
		}

		stmt = tx.Stmt(svc.stmts["update-{{.dbModel}}"])
	} else {
		stmt = svc.stmts["update-{{.dbModel}}"]
	}

	result, err := stmt.ExecContext(ctx, input.Name, input.{{$pascalDbModel}}ID)
	if err != nil {
		return errors.Wrap(err, errMsg())
	}

	rowCount, err := result.RowsAffected()
	if err != nil {
		return errors.Wrap(err, errMsg())
	}

	if rowCount == 0 {
		return errors.Wrap(ErrNoRowsAffected, errMsg())
	}

	return nil
}

// Delete sets deleted_at for a single {{.dbModel}}s row
func (svc *{{.dbModel}}Service) Delete(ctx context.Context, ID uuid.UUID) error {
	return svc.delete(ctx, false, ID)
}

// DeleteTx sets deleted_at for a single {{.dbModel}}s row within a tx from ctx
func (svc *{{.dbModel}}Service) DeleteTx(ctx context.Context, ID uuid.UUID) error {
	return svc.delete(ctx, true, ID)
}

// delete a {{.dbModel}} by setting deleted at. if useTx = true then it will attempt to delete the {{.dbModel}} within a transaction
// from context.
func (svc *{{.dbModel}}Service) delete(ctx context.Context, useTx bool, ID uuid.UUID) error {
	errMsg := func() string { return "Error executing delete {{.dbModel}} - " + ID.String() }

	var (
		stmt *sql.Stmt
		err  error
		tx   *sql.Tx
	)

	if useTx {

		if tx, err = FromCtx(ctx); err != nil {
			return err
		}

		stmt = tx.Stmt(svc.stmts["delete-{{.dbModel}}"])
	} else {
		stmt = svc.stmts["delete-{{.dbModel}}"]
	}

	result, err := stmt.ExecContext(ctx, ID)
	if err != nil {
		return errors.Wrap(err, errMsg())
	}

	rowCount, err := result.RowsAffected()
	if err != nil {
		return errors.Wrap(err, errMsg())
	}

	if rowCount == 0 {
		return errors.Wrap(ErrNotFound, errMsg())
	}

	return nil
}

